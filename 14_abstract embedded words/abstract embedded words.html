<!DOCTYPE html><html><head>
      <title>abstract embedded words</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      
      <link rel="stylesheet" href="file:///c:\Users\jerry\.vscode\extensions\shd101wyy.markdown-preview-enhanced-0.8.13\crossnote\dependencies\katex\katex.min.css">
      
      
      
      
      
      <style>
      code[class*=language-],pre[class*=language-]{color:#333;background:0 0;font-family:Consolas,"Liberation Mono",Menlo,Courier,monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.4;-moz-tab-size:8;-o-tab-size:8;tab-size:8;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]{padding:.8em;overflow:auto;border-radius:3px;background:#f5f5f5}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal;background:#f5f5f5}.token.blockquote,.token.comment{color:#969896}.token.cdata{color:#183691}.token.doctype,.token.macro.property,.token.punctuation,.token.variable{color:#333}.token.builtin,.token.important,.token.keyword,.token.operator,.token.rule{color:#a71d5d}.token.attr-value,.token.regex,.token.string,.token.url{color:#183691}.token.atrule,.token.boolean,.token.code,.token.command,.token.constant,.token.entity,.token.number,.token.property,.token.symbol{color:#0086b3}.token.prolog,.token.selector,.token.tag{color:#63a35c}.token.attr-name,.token.class,.token.class-name,.token.function,.token.id,.token.namespace,.token.pseudo-class,.token.pseudo-element,.token.url-reference .token.variable{color:#795da3}.token.entity{cursor:help}.token.title,.token.title .token.punctuation{font-weight:700;color:#1d3e81}.token.list{color:#ed6a43}.token.inserted{background-color:#eaffea;color:#55a532}.token.deleted{background-color:#ffecec;color:#bd2c00}.token.bold{font-weight:700}.token.italic{font-style:italic}.language-json .token.property{color:#183691}.language-markup .token.tag .token.punctuation{color:#333}.language-css .token.function,code.language-css{color:#0086b3}.language-yaml .token.atrule{color:#63a35c}code.language-yaml{color:#183691}.language-ruby .token.function{color:#333}.language-markdown .token.url{color:#795da3}.language-makefile .token.symbol{color:#795da3}.language-makefile .token.variable{color:#183691}.language-makefile .token.builtin{color:#0086b3}.language-bash .token.keyword{color:#0086b3}pre[data-line]{position:relative;padding:1em 0 1em 3em}pre[data-line] .line-highlight-wrapper{position:absolute;top:0;left:0;background-color:transparent;display:block;width:100%}pre[data-line] .line-highlight{position:absolute;left:0;right:0;padding:inherit 0;margin-top:1em;background:hsla(24,20%,50%,.08);background:linear-gradient(to right,hsla(24,20%,50%,.1) 70%,hsla(24,20%,50%,0));pointer-events:none;line-height:inherit;white-space:pre}pre[data-line] .line-highlight:before,pre[data-line] .line-highlight[data-end]:after{content:attr(data-start);position:absolute;top:.4em;left:.6em;min-width:1em;padding:0 .5em;background-color:hsla(24,20%,50%,.4);color:#f4f1ef;font:bold 65%/1.5 sans-serif;text-align:center;vertical-align:.3em;border-radius:999px;text-shadow:none;box-shadow:0 1px #fff}pre[data-line] .line-highlight[data-end]:after{content:attr(data-end);top:auto;bottom:.4em}html body{font-family:'Helvetica Neue',Helvetica,'Segoe UI',Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ol,html body>ul{margin-bottom:16px}html body ol,html body ul{padding-left:2em}html body ol.no-list,html body ul.no-list{padding:0;list-style-type:none}html body ol ol,html body ol ul,html body ul ol,html body ul ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;background-color:#f0f0f0;border-left:4px solid #d6d6d6}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:700;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:700}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::after,html body code::before{letter-spacing:-.2em;content:'\00a0'}html body pre>code{padding:0;margin:0;word-break:normal;white-space:pre;background:0 0;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:after,html body pre code:before,html body pre tt:after,html body pre tt:before{content:normal}html body blockquote,html body dl,html body ol,html body p,html body pre,html body ul{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body code,html body pre{word-wrap:break-word;white-space:pre}}.markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview ul{list-style:disc}.markdown-preview ul ul{list-style:circle}.markdown-preview ul ul ul{list-style:square}.markdown-preview ol{list-style:decimal}.markdown-preview ol ol,.markdown-preview ul ol{list-style-type:lower-roman}.markdown-preview ol ol ol,.markdown-preview ol ul ol,.markdown-preview ul ol ol,.markdown-preview ul ul ol{list-style-type:lower-alpha}.markdown-preview .newpage,.markdown-preview .pagebreak{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers>code{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center!important}.markdown-preview:not([data-for=preview]) .code-chunk .code-chunk-btn-group{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .status{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .output-div{margin-bottom:16px}.markdown-preview .md-toc{padding:0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link div,.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}.markdown-preview .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0;min-height:100vh}@media screen and (min-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px + 2em)}}@media screen and (max-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{font-size:14px!important;padding:1em}}@media print{html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc{padding:0 16px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link div,html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% - 300px);padding:2em calc(50% - 457px - 300px / 2);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none}
/* Please visit the URL below for more information: */
/*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */

      </style>
      <!-- The content below will be included at the end of the <head> element. --><script type="text/javascript">
  document.addEventListener("DOMContentLoaded", function () {
    // your code here
  });
</script></head><body for="html-export">
    
    
      <div class="crossnote markdown-preview  ">
      
<h1>嵌入式科普(14)指针---这些年嵌入式工程师也不容易的词语</h1>

<div class="md-toc">
<details style="padding:0;;padding-left:0px;" open="">
        <summary class="md-toc-link-wrapper">
          <a href="#一-指针pointer" class="md-toc-link"><p>一、指针（Pointer）：</p>
</a>
          </summary>
        <div>
          <div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#11-动态内存管理" class="md-toc-link">
            <p>1.1 动态内存管理：</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#12-数组和字符串操作" class="md-toc-link">
            <p>1.2 数组和字符串操作：</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#13-函数参数传递" class="md-toc-link">
            <p>1.3 函数参数传递：</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#14-数据结构实现链表" class="md-toc-link">
            <p>1.4 数据结构实现（链表）：</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#15-实现回调函数" class="md-toc-link">
            <p>1.5 实现回调函数：</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#16-提高性能直接内存访问示例" class="md-toc-link">
            <p>1.6 提高性能（直接内存访问示例）：</p>

          </a></div>
        </div>
      </details>
    <div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:18px">
          <a href="#二-对象object" class="md-toc-link">
            <p>二、对象（Object）：</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:18px">
          <a href="#三-句柄handle" class="md-toc-link">
            <p>三、句柄（Handle）：</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:18px">
          <a href="#四-套接字socket" class="md-toc-link">
            <p>四、套接字（Socket）：</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:18px">
          <a href="#五-描述符descriptor" class="md-toc-link">
            <p>五、描述符（Descriptor）：</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:18px">
          <a href="#六-实例instance" class="md-toc-link">
            <p>六、实例（Instance）：</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:18px">
          <a href="#七-令牌token" class="md-toc-link">
            <p>七、令牌（Token）：</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:18px">
          <a href="#八-签名signature" class="md-toc-link">
            <p>八、签名（Signature）：</p>

          </a></div>
</div>
<h1 id="一-指针pointer">一、指针（Pointer）： </h1>
<p>指针是C/C++中的一个重要概念，它存储了一个变量的内存地址。通过指针，可以直接访问和操作内存中的数据。<br>
C语言示例：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>#include &lt;stdio.h&gt;  
  
int main() {  
    int x = 10;  
    int *ptr = &amp;x; // ptr 是一个指向 x 的指针  
    printf("Value of x: %d\n", *ptr); // 输出 x 的值，使用 * 运算符解引用指针  
    *ptr = 20; // 通过指针修改 x 的值  
    printf("Value of x after modification: %d\n", x); // 输出修改后的 x 的值  
    return 0;  
}
</code></pre><p><strong>C语言中指针的六个重要应用的示例代码</strong>：</p>
<h2 id="11-动态内存管理">1.1 动态内存管理： </h2>
<pre data-role="codeBlock" data-info="" class="language-text"><code>#include &lt;stdio.h&gt;  
#include &lt;stdlib.h&gt;  
  
int main() {  
    int *ptr = (int *)malloc(sizeof(int)); // 动态分配内存  
    if (ptr == NULL) {  
        perror("Memory allocation failed");  
        return 1;  
    }  
    *ptr = 42; // 使用指针设置值  
    printf("Value: %d\n", *ptr); // 输出值  
    free(ptr); // 释放内存  
    return 0;  
}
</code></pre><h2 id="12-数组和字符串操作">1.2 数组和字符串操作： </h2>
<pre data-role="codeBlock" data-info="" class="language-text"><code>#include &lt;stdio.h&gt;  
  
int main() {  
    int array[] = {1, 2, 3, 4, 5};  
    int *ptr = array; // 指针指向数组首元素  
    for (int i = 0; i &lt; 5; i++) {  
        printf("%d ", *(ptr + i)); // 使用指针遍历数组  
    }  
    printf("\n");  
    char str[] = "Hello";  
    char *str_ptr = str; // 指针指向字符串首字符  
    printf("%s\n", str_ptr); // 使用指针输出字符串  
    return 0;  
}
</code></pre><h2 id="13-函数参数传递">1.3 函数参数传递： </h2>
<pre data-role="codeBlock" data-info="" class="language-text"><code>#include &lt;stdio.h&gt;  
  
void increment(int *value) {  
    (*value)++; // 通过指针修改值  
}  
  
int main() {  
    int num = 5;  
    increment(&amp;num); // 传递变量的地址  
    printf("Incremented value: %d\n", num); // 输出修改后的值  
    return 0;  
}
</code></pre><h2 id="14-数据结构实现链表">1.4 数据结构实现（链表）： </h2>
<pre data-role="codeBlock" data-info="" class="language-text"><code>#include &lt;stdio.h&gt;  
#include &lt;stdlib.h&gt;  
  
typedef struct Node {  
    int data;  
    struct Node *next;  
} Node;  
  
int main() {  
    Node *head = (Node *)malloc(sizeof(Node)); // 创建头节点  
    head-&gt;data = 1;  
    head-&gt;next = NULL;  
  
    Node *second = (Node *)malloc(sizeof(Node)); // 创建第二个节点  
    second-&gt;data = 2;  
    second-&gt;next = NULL;  
    head-&gt;next = second; // 将第二个节点链接到头节点  
  
    Node *current = head; // 使用指针遍历链表  
    while (current != NULL) {  
        printf("%d ", current-&gt;data);  
        current = current-&gt;next;  
    }  
    printf("\n");  
  
    // 释放链表内存（略）  
    return 0;  
}
</code></pre><h2 id="15-实现回调函数">1.5 实现回调函数： </h2>
<pre data-role="codeBlock" data-info="" class="language-text"><code>#include &lt;stdio.h&gt;  
  
// 回调函数类型定义  
typedef void (*Callback)(int);  
  
// 回调函数实现  
void print_value(int value) {  
    printf("Callback called with value: %d\n", value);  
}  
  
// 接受回调函数的函数  
void process_data(int data, Callback callback) {  
    // ... 执行一些操作 ...  
    callback(data); // 调用回调函数  
}  
  
int main() {  
    process_data(10, print_value); // 传递回调函数作为参数  
    return 0;  
}
</code></pre><h2 id="16-提高性能直接内存访问示例">1.6 提高性能（直接内存访问示例）： </h2>
<pre data-role="codeBlock" data-info="" class="language-text"><code>#include &lt;stdio.h&gt;  
#include &lt;time.h&gt;  
  
#define ARRAY_SIZE 1000000  
  
int main() {  
    int array[ARRAY_SIZE];  
    int *ptr = array;  
  
    // 使用指针直接访问内存来填充数组  
    clock_t start = clock();  
    for (int i = 0; i &lt; ARRAY_SIZE; i++) {  
        *(ptr + i) = i;  
    }  
    clock_t end = clock();  
    double time_taken_ptr = (double)(end - start) / CLOCKS_PER_SEC;  
    printf("Time taken using pointer: %f seconds\n", time_taken_ptr);  
  
    // 使用数组索引来填充数组  
    start = clock();  
    for (int i = 0; i &lt; ARRAY_SIZE; i++) {  
        array[i] = i;  
    }  
    end = clock();  
    double time_taken_index = (double)(end - start) / CLOCKS_PER_SEC;  
    printf("Time taken using array index: %f seconds\n", time_taken_index);  
  
    // 输出两种方法的性能差异（如果有的话）  
    if (time_taken_ptr &lt; time_taken_index) {  
        printf("Pointer access was faster.\n");  
    } else if (time_taken_ptr &gt; time_taken_index) {  
        printf("Array index access was faster.\n");  
    } else {  
        printf("No significant difference.\n");  
    }  
  
    return 0;  
}
</code></pre><h1 id="二-对象object">二、对象（Object）： </h1>
<p>在C++中，对象是类的实例，具有属性和方法。对象是面向对象编程（OOP）的基本构建块。<br>
C++示例：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>#include &lt;iostream&gt;  
#include &lt;string&gt;  
  
class Dog {  
public:  
    std::string name;  
    int age;  
  
    void bark() {  
        std::cout &lt;&lt; name &lt;&lt; " says Woof!" &lt;&lt; std::endl;  
    }  
};  
  
int main() {  
    Dog myDog; // myDog 是 Dog 类的一个对象  
    myDog.name = "Buddy";  
    myDog.age = 3;  
    myDog.bark(); // 调用对象的方法  
    return 0;  
}
</code></pre><h1 id="三-句柄handle">三、句柄（Handle）： </h1>
<p>句柄通常用于表示系统资源（如文件、网络连接等）的引用。在C/C++中，句柄通常是以某种形式（如整数或指针）表示的标识符，用于在API调用中引用这些资源。<br>
由于句柄的具体实现取决于操作系统和API，因此很难给出一个通用的C/C++示例。但通常，句柄是通过调用系统API函数（如打开文件或创建网络连接）获得的，并在后续的操作中用作参数。</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>#include &lt;stdio.h&gt;  
#include &lt;stdlib.h&gt;  
  
// 假设我们有一个内存池，我们使用整数句柄来引用它  
typedef struct {  
    int* data;  
    size_t size;  
} MemoryBlock;  
  
// 内存池管理  
typedef struct {  
    MemoryBlock* blocks;  
    size_t capacity;  
    size_t used;  
} MemoryPool;  
  
// 初始化内存池  
void initMemoryPool(MemoryPool* pool, size_t capacity) {  
    pool-&gt;blocks = (MemoryBlock*)malloc(capacity * sizeof(MemoryBlock));  
    pool-&gt;capacity = capacity;  
    pool-&gt;used = 0;  
}  
  
// 分配内存并返回句柄  
int allocateMemory(MemoryPool* pool, size_t size) {  
    if (pool-&gt;used &gt;= pool-&gt;capacity) {  
        fprintf(stderr, "Memory pool is full!\n");  
        return -1; // 返回错误句柄  
    }  
    MemoryBlock* newBlock = &amp;pool-&gt;blocks[pool-&gt;used];  
    newBlock-&gt;data = (int*)malloc(size * sizeof(int));  
    newBlock-&gt;size = size;  
    int handle = (int)pool-&gt;used; // 句柄是内存在blocks数组中的索引  
    pool-&gt;used++;  
    return handle;  
}  
  
// 使用句柄获取内存块的指针  
int* getMemoryByHandle(MemoryPool* pool, int handle) {  
    if (handle &lt; 0 || handle &gt;= pool-&gt;used) {  
        fprintf(stderr, "Invalid handle!\n");  
        return NULL;  
    }  
    return pool-&gt;blocks[handle].data;  
}  
  
// 释放内存池中的内存块  
void freeMemoryByHandle(MemoryPool* pool, int handle) {  
    if (handle &lt; 0 || handle &gt;= pool-&gt;used) {  
        fprintf(stderr, "Invalid handle!\n");  
        return;  
    }  
    free(pool-&gt;blocks[handle].data);  
    pool-&gt;blocks[handle].data = NULL;  
    pool-&gt;blocks[handle].size = 0;  
}  
  
// 清理内存池  
void cleanupMemoryPool(MemoryPool* pool) {  
    for (size_t i = 0; i &lt; pool-&gt;used; i++) {  
        free(pool-&gt;blocks[i].data);  
    }  
    free(pool-&gt;blocks);  
    pool-&gt;blocks = NULL;  
    pool-&gt;capacity = 0;  
    pool-&gt;used = 0;  
}  
  
int main() {  
    MemoryPool pool;  
    initMemoryPool(&amp;pool, 10); // 初始化一个容量为10的内存池  
  
    int handle = allocateMemory(&amp;pool, 5); // 分配5个整数的内存块，并获取句柄  
    if (handle != -1) {  
        int* memory = getMemoryByHandle(&amp;pool, handle); // 使用句柄获取内存块指针  
        if (memory) {  
            for (size_t i = 0; i &lt; 5; i++) {  
                memory[i] = i * i; // 在内存中存储平方值  
            }  
            // ... 使用内存块 ...  
            freeMemoryByHandle(&amp;pool, handle); // 释放内存块  
        }  
    }  
  
    cleanupMemoryPool(&amp;pool); // 清理内存池  
    return 0;  
}
</code></pre><pre data-role="codeBlock" data-info="" class="language-text"><code>#include &lt;stdio.h&gt;  
#include &lt;stdlib.h&gt;  
  
int main() {  
    // 打开文件以写入数据，获取文件句柄（FILE *指针）  
    FILE *fileHandle = fopen("example.txt", "w");  
    if (fileHandle == NULL) {  
        perror("Error opening file for writing");  
        return EXIT_FAILURE;  
    }  
  
    // 使用文件句柄写入数据到文件  
    const char *text = "Hello, World!\n";  
    fputs(text, fileHandle);  
  
    // 关闭文件句柄  
    fclose(fileHandle);  
  
    // 打开同一个文件以读取数据  
    fileHandle = fopen("example.txt", "r");  
    if (fileHandle == NULL) {  
        perror("Error opening file for reading");  
        return EXIT_FAILURE;  
    }  
  
    // 读取文件内容  
    char buffer[1024];  
    while (fgets(buffer, sizeof(buffer), fileHandle) != NULL) {  
        printf("%s", buffer);  
    }  
  
    // 关闭文件句柄  
    fclose(fileHandle);  
  
    return EXIT_SUCCESS;  
}
</code></pre><h1 id="四-套接字socket">四、套接字（Socket）： </h1>
<p>套接字是网络编程中的基本概念，用于实现不同计算机之间的通信。在C/C++中，套接字通常通过系统调用和相关的网络库来创建和使用。<br>
C语言示例（使用BSD套接字API）：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>#include &lt;stdio.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;string.h&gt;  
#include &lt;unistd.h&gt;  
#include &lt;sys/types.h&gt;  
#include &lt;sys/socket.h&gt;  
#include &lt;netinet/in.h&gt;  
#include &lt;arpa/inet.h&gt;  
  
int main() {  
    int sockfd;  
    struct sockaddr_in serv_addr;  
    char *hello = "Hello from client";  
  
    sockfd = socket(AF_INET, SOCK_STREAM, 0);  
    if (sockfd &lt; 0) {  
        perror("ERROR opening socket");  
        exit(1);  
    }  
  
    bzero((char *) &amp;serv_addr, sizeof(serv_addr));  
    serv_addr.sin_family = AF_INET;  
    serv_addr.sin_addr.s_addr = inet_addr("127.0.0.1");  
    serv_addr.sin_port = htons(12345);  
  
    if (connect(sockfd, (struct sockaddr *) &amp;serv_addr, sizeof(serv_addr)) &lt; 0) {  
        perror("ERROR connecting");  
        exit(1);  
    }  
  
    send(sockfd, hello, strlen(hello), 0);  
    close(sockfd);  
    return 0;  
}
</code></pre><h1 id="五-描述符descriptor">五、描述符（Descriptor）： </h1>
<p>描述符通常用于表示打开的文件、网络连接或其他I/O资源的标识符。在C/C++中，文件描述符是常见的例子，它们是由open系统调用返回的整数，用于在后续的文件操作中标识特定的文件。</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>#include &lt;stdio.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;fcntl.h&gt;  
#include &lt;unistd.h&gt;  
#include &lt;string.h&gt;  
#include &lt;sys/stat.h&gt;  
#include &lt;sys/types.h&gt;  
  
int main() {  
    // 打开文件以写入数据，获取文件描述符  
    int fd = open("example.txt", O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR);  
    if (fd == -1) {  
        perror("Error opening file for writing");  
        return EXIT_FAILURE;  
    }  
  
    // 使用文件描述符写入数据到文件  
    const char *text = "Hello, World!\n";  
    ssize_t bytesWritten = write(fd, text, strlen(text));  
    if (bytesWritten == -1) {  
        perror("Error writing to file");  
        close(fd); // 关闭文件描述符  
        return EXIT_FAILURE;  
    }  
  
    // 关闭文件描述符  
    close(fd);  
  
    // 打开同一个文件以读取数据  
    fd = open("example.txt", O_RDONLY);  
    if (fd == -1) {  
        perror("Error opening file for reading");  
        return EXIT_FAILURE;  
    }  
  
    // 读取文件内容  
    char buffer[1024];  
    ssize_t bytesRead = read(fd, buffer, sizeof(buffer) - 1); // 减1以保留空间给'\0'  
    if (bytesRead == -1) {  
        perror("Error reading from file");  
        close(fd); // 关闭文件描述符  
        return EXIT_FAILURE;  
    }  
  
    // 在buffer末尾添加null终止符  
    buffer[bytesRead] = '\0';  
  
    // 打印读取到的内容  
    printf("Read from file: %s", buffer);  
  
    // 关闭文件描述符  
    close(fd);  
  
    return EXIT_SUCCESS;  
}
</code></pre><h1 id="六-实例instance">六、实例（Instance）： </h1>
<p>在面向对象的编程中，实例是类的一个具体对象。当创建类的一个新对象时，就得到了该类的一个实例。<br>
C++示例（继续上面的Dog类）：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>#include &lt;iostream&gt;  
#include &lt;string&gt;  
  
class Dog {  
public:  
    std::string name;  
    int age;  
  
    Dog(std::string name, int age) : name(name), age(age) {} // 构造函数  
  
    void bark() {  
        std::cout &lt;&lt; name &lt;&lt; " says Woof!" &lt;&lt; std::endl;  
    }  
};  
  
int main() {  
    Dog myDog("Buddy", 3); // myDog 是 Dog 类的一个实例  
    myDog.bark(); // 调用实例的方法  
    return 0;  
}
</code></pre><p>在C语言中，"实例"（instance）这个术语通常与面向对象编程（OOP）相关，而C语言本身并不是一种面向对象的编程语言。然而，我们可以模拟面向对象的某些概念，比如结构体（struct）可以被视为类的实例。以下是一个使用结构体作为"实例"的C语言例子：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>#include &lt;stdio.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;string.h&gt;  
  
// 定义一个结构体，类似于一个类  
typedef struct {  
    char name[50];  
    int age;  
} Person;  
  
// 创建一个函数，用于初始化Person实例  
void createPerson(Person *person, const char *name, int age) {  
    strcpy(person-&gt;name, name);  
    person-&gt;age = age;  
}  
  
// 创建一个函数，用于打印Person实例的信息  
void printPerson(const Person *person) {  
    printf("Name: %s\n", person-&gt;name);  
    printf("Age: %d\n", person-&gt;age);  
}  
  
int main() {  
    // 创建Person的实例（结构体变量）  
    Person alice;  
      
    // 初始化Person实例  
    createPerson(&amp;alice, "Alice", 30);  
      
    // 打印Person实例的信息  
    printPerson(&amp;alice);  
      
    // 创建另一个Person实例  
    Person bob;  
    createPerson(&amp;bob, "Bob", 25);  
    printPerson(&amp;bob);  
      
    return 0;  
}
</code></pre><h1 id="七-令牌token">七、令牌（Token）： </h1>
<p>在计算机编程和操作系统中，令牌通常用于表示对某种资源的访问权限。例如，在并发编程中，令牌可以用来控制对共享资源的访问，实现同步机制。<br>
由于令牌的具体实现和应用场景多种多样，很难提供一个通用的C/C++示例。令牌的使用通常依赖于特定的库或框架，例如线程同步原语（如信号量或互斥锁）可能使用内部令牌来控制资源的访问。</p>
<p>在C语言中，通常不会直接使用“令牌”（Token）这个术语，因为令牌是编译器在处理源代码时的一个内部概念。编译器会把源代码文本分解成一系列的令牌，这些令牌是源代码的最小语法单元，例如关键字、标识符、运算符、分隔符、字面量等。</p>
<p>然而，如果我们想要模拟令牌的概念，并手动解析和处理一些简单的“令牌流”，我们可以编写一个简单的C语言程序来模拟这个过程。以下是一个简单的例子，该程序定义了一些令牌类型，并模拟了令牌的产生和处理过程：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>#include &lt;stdio.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;string.h&gt;  
  
// 定义令牌类型  
typedef enum {  
    TOKEN_IDENTIFIER,  
    TOKEN_NUMBER,  
    TOKEN_PLUS,  
    TOKEN_MINUS,  
    TOKEN_MUL,  
    TOKEN_DIV,  
    TOKEN_EOL, // 行结束符  
    TOKEN_UNKNOWN, // 未知令牌  
    TOKEN_EOF // 文件结束符  
} TokenType;  
  
// 定义令牌结构体  
typedef struct {  
    TokenType type;  
    char value[50];  
} Token;  
  
// 假设的令牌生成函数，这里简单模拟  
Token generate_token(const char **input) {  
    Token token;  
    token.type = TOKEN_UNKNOWN;  
    strcpy(token.value, "");  
  
    // 跳过空白字符  
    while (**input == ' ') (*input)++;  
  
    if (**input == '\0') {  
        token.type = TOKEN_EOF;  
        return token;  
    }  
  
    // 识别不同的令牌类型  
    switch (**input) {  
        case '+':  
            token.type = TOKEN_PLUS;  
            break;  
        case '-':  
            token.type = TOKEN_MINUS;  
            break;  
        case '*':  
            token.type = TOKEN_MUL;  
            break;  
        case '/':  
            token.type = TOKEN_DIV;  
            break;  
        case '\n':  
            token.type = TOKEN_EOL;  
            break;  
        default:  
            if (isdigit(**input)) {  
                token.type = TOKEN_NUMBER;  
                while (isdigit(**input)) {  
                    token.value[strlen(token.value)] = **input;  
                    (*input)++;  
                }  
                token.value[strlen(token.value)] = '\0';  
            } else if (isalpha(**input)) {  
                token.type = TOKEN_IDENTIFIER;  
                while (isalnum(**input)) {  
                    token.value[strlen(token.value)] = **input;  
                    (*input)++;  
                }  
                token.value[strlen(token.value)] = '\0';  
            } else {  
                // 未知字符  
                token.type = TOKEN_UNKNOWN;  
                (*input)++;  
            }  
    }  
    (*input)++; // 移动到下一个字符  
    return token;  
}  
  
int main() {  
    const char *input = "a + 5 * b\n"; // 示例输入  
    Token token;  
  
    do {  
        token = generate_token(&amp;input);  
        switch (token.type) {  
            case TOKEN_IDENTIFIER:  
                printf("Identifier: %s\n", token.value);  
                break;  
            case TOKEN_NUMBER:  
                printf("Number: %s\n", token.value);  
                break;  
            case TOKEN_PLUS:  
                printf("Operator: +\n");  
                break;  
            case TOKEN_MINUS:  
                printf("Operator: -\n");  
                break;  
            case TOKEN_MUL:  
                printf("Operator: *\n");  
                break;  
            case TOKEN_DIV:  
                printf("Operator: /\n");  
                break;  
            case TOKEN_EOL:  
                printf("End of line\n");  
                break;  
            case TOKEN_UNKNOWN:  
                printf("Unknown token\n");  
                break;  
            case TOKEN_EOF:  
                printf("End of file\n");  
                break;  
        }  
    } while (token.type != TOKEN_EOF);  
  
    return 0;  
}
</code></pre><p>在这个例子中，我们定义了一个Token结构体来存储令牌的类型和值。generate_token函数模拟了从输入字符串中生成令牌的过程。在main函数中，我们遍历输入的字符串，生成并打印出每一个令牌。</p>
<p>请注意，这个例子是非常简化的，并且只是为了演示目的。在实际的编译器中，令牌化（tokenization）是一个更复杂的过程，涉及词法分析（lexical analysis）和更严格的语法规则。此外，编译器通常还会</p>
<h1 id="八-签名signature">八、签名（Signature）： </h1>
<p>签名通常用于验证数据或消息的完整性和来源。在编程中，它可能指函数的签名，即函数的名称和参数类型列表，用于唯一标识一个函数。<br>
C++示例（函数签名）：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>#include &lt;iostream&gt;  
  
// 这是一个函数签名，它声明了一个名为 add 的函数，接受两个 int 参数，并返回一个 int 结果  
int add(int a, int b);  
  
int add(int a, int b) { // 这是函数的定义，它实现了上述签名  
    return a + b;  
}  
  
int main() {  
    int sum = add(5, 3); // 调用函数，使用其签名匹配正确的函数定义  
    std::cout &lt;&lt; "Sum: " &lt;&lt; sum &lt;&lt; std::endl;  
    return 0;  
}
</code></pre>
      </div>
      
      
    
    
    
    
    
    
  
    </body></html>